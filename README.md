# Locale
 Создание пакета ресурсов файла свойств
К счастью, Java не требует от нас создания четырех разных пакетов ресурсов. Если у нас нет пакета ресурсов для конкретной страны,
Java будет использовать язык для конкретного языка. 
На данный момент нам нужны английские и французские пакеты ресурсов файла свойств. Сначала создайте два файла свойств:

1 пример

Zoo_en.properties     
   hello=Hello       
 open=The zoo is open. 
Zoo_fr.properties        
hello=Bonjour       
 open=Le zoo est ouvert
Обратите внимание, что имена файлов - это имя нашего пакета ресурсов, за которым следует подчеркивание, за которым следует целевой языковой стандарт. 
Мы можем написать нашу самую первую программу, которая использует пакет ресурсов для печати этой информации:
1:    import java.util.*;
2:    public class ZooOpen {
3:
4:       public static void main(String[] args) {
5:          Locale us = new Locale("en", "US");
6:          Locale france = new Locale("fr", "FR");
7:
8:          printProperties(us);
9:          System.out.println();
10:         printProperties(france);
11:      }
12:
13:      public static void printProperties(Locale locale) {
14:         ResourceBundle rb = ResourceBundle.getBundle("Zoo", locale);
15:         System.out.println(rb.getString("hello"));
16:         System.out.println(rb.getString("open"));
17:      }
18:  }
Строки 5 и 6 создают локали, которые мы хотим протестировать. Метод в строках 13–17 выполняет фактическую работу.
Строка 14 вызывает фабричный метод ResourceBundleдля получения правильного пакета ресурсов. Строки 15 и 16 извлекают правильный пакет ресурсов и распечатывают результаты.
Вывод следующий:
Hello
The zoo is open.
 Bonjour
Le zoo est ouvert
Обратите внимание, что здесь происходит за кулисами. Java использует имя bundle ( Zoo) и ищет соответствующий файл свойств.
Вы увидите это снова позже в этой главе и узнаете, как Java выясняет, какой из них использовать.
Формат файла свойств
Наиболее распространенный синтаксис - это когда файл свойств содержит пары ключ / значение в формате:
animal=dolphin
Это больше, чем это. На самом деле есть два других формата, которые вы можете использовать для выражения этих пар. 
Даже если вы никогда не используете их в своей работе, вы должны знать их для экзамена:
animal:dolphin
animal dolphin
Вы можете задаться вопросом, как выразить некоторые другие идеи в файле свойств. Общие из них:
•	Если строка начинается с #или !, это комментарий.
•	Пробелы до или после символа разделителя игнорируются.
•	Пробелы в начале строки игнорируются.
•	Пробелы в конце строки не игнорируются.
•	Завершите строку обратной косой чертой, если вы хотите разбить строку для удобства чтения.
•	Вы можете использовать обычные escape-символы Java, такие как \tи \n.
Собрав их вместе, мы можем написать следующее:
# one comment
! another comment
key =   value\tafter tab
long = abcdefghijklm\
 nopqrstuvwxyz
Распечатка этих двух свойств в программе дает нам это:
value ⃗ after tab
abcdefghijklmnopqrstuvwxyz

 2 пример
 
Поскольку пакет ресурсов содержит пары ключ / значение, вы можете даже просмотреть их, чтобы получить список всех пар.
ResourceBundleКласс предоставляет метод , чтобы получить набор всех ключей:
Locale us = new Locale("en", "US");
ResourceBundle rb = ResourceBundle.getBundle("Zoo", us);
 Set<String> keys = rb.keySet();
keys.stream().map(k -> k + " " + rb.getString(k))         
    .forEach(System.out::println);
Этот пример проходит через все ключи. Он сопоставляет каждый ключ Stringс ключом и значением перед печатью всего. Это печатает
name Vancouver Zoo
hello Hello
open The zoo is open
И да, мы могли бы использовать традиционный forцикл. Для экзамена необходимо знать как циклы, так и функциональное программирование,
поэтому мы используем оба подхода на протяжении всей книги.


3 пример

В дополнение к ResourceBundleJava поддерживает класс с именем Properties. Это похоже на Mapто, о чем вы узнали в главе 3 «Обобщения и коллекции».
Он был написан до того, как Mapсуществовал, поэтому он не использует все те же имена методов.
Propertiesимеет некоторые дополнительные функции, включая возможность передать значение по умолчанию. Преобразовать из ResourceBundleв Propertiesлегко:

Properties props = new Properties();
rb.keySet().stream()       
    .forEach(k -> props.put(k, rb.getString(k)));

Здесь мы прошли каждый ключ и использовали его, Consumerчтобы добавить его к Propertiesобъекту. Теперь, когда мы Propertiesдоступны, мы можем получить значение по умолчанию:
System.out.println(props.getProperty("notReallyAProperty"));
System.out.println(props.getProperty("notReallyAProperty", "123"));
Первая строка печатается null, так как это свойство не существует. Второй печатает 123, так как имущество не найдено.
Если бы был передан ключ, который действительно существовал, оба вернули бы его.
Обратите внимание, что метод называется getProperty(). Существует также get()метод, который мы ожидаем от любой коллекции. 
Допускает только значение getProperty()по умолчанию.
Таблица 5.6 показывает различные сценарии с getProperty(). Как видите, nullвозвращается, когда мы не передаем значение по умолчанию и ключ не найден.
Когда мы передаем значение по умолчанию, оно используется вместо этого.
Таблица 5.6. Возвращаемые значения дляgetProperty()

Ключ найден?	                            да	                             нет
getProperty("key")	                   Value	                            null
getProperty("key", "default")	          Value                         	"default"




Создание пакета ресурсов класса Java

В большинстве случаев для удовлетворения потребностей программы достаточно пакета ресурсов файла свойств. Он имеет ограничение в том, 
что Stringразрешены только значения. Пакеты ресурсов класса Java позволяют использовать любой тип Java в качестве значения. Ключи являются строками независимо.
Чтобы реализовать пакет ресурсов в Java, вы создаете класс с тем же именем, которое вы использовали бы для файла свойств. 
Только расширение отличается. Поскольку у нас есть объект Java, файл должен быть .javaфайлом, а не .propertiesфайлом. Например, следующий класс эквивалентен файлу свойств, который вы видели в последнем разделе:

1:    import java.util.*;
2:    public class Zoo_en extends ListResourceBundle {
3:       protected Object[][] getContents() {
4:          return new Object[][] {
5:             { "hello", "Hello" },
6:             { "open", "The zoo is open" } };
7:       } }
В строке 2 показан суперкласс для пакетов ресурсов классов Java. ListResourceBundleАбстрактный класс оставляет один метод подклассы для реализации.
Оставшаяся часть кода создает двумерный массив с ключами helloи open.

